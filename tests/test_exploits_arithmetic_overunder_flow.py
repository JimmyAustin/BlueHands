from speculative_machine_executor import SpeculativeMachineExecutor
from speculative_machine import SpeculativeMachine 
from z3 import BitVecVal
from utils import bytes_to_int, int_to_bytes, parse_solidity_abi_input, func_sig, \
    eth_to_wei, ready_hex, pad_bytes_to_address, uint_to_bytes, summarise_possible_end, \
    load_binary, bytes_to_uint
from speculative_machine_executor import calculate_results_for_machine
from datetime import datetime
from universe import Universe
from speculative_universe_executor import SpeculativeUniverseExecutor

# Timelock.sol
# contract TimeLock {
    
#     mapping(address => uint) public balances;
#     mapping(address => uint) public lockTime;
    
#     function deposit() public payable {
#         balances[msg.sender] += msg.value;
#         lockTime[msg.sender] = now + 1 weeks;
#     }
    
#     function increaseLockTime(uint _secondsToIncrease) public {
#         lockTime[msg.sender] += _secondsToIncrease;
#     }
    
#     function withdraw() public {
#         require(balances[msg.sender] > 0);
#         require(now > lockTime[msg.sender]);
#         msg.sender.transfer(balances[msg.sender]);
#         balances[msg.sender] = 0;
#     }
# }

def test_get_timelock_overflow_actually_works():
    binary = load_binary('contracts/build/TimeLock.bin')

    universe = Universe()
    contract = universe.deploy_contract(binary)

    locker_wallet = universe.deploy_wallet(starting_wallet_amount=eth_to_wei(5))

    starting_timestamp = int(datetime(2018, 1, 1).timestamp())

    contract.execute_function('deposit()', [], call_value=uint_to_bytes(eth_to_wei(5)), 
                              timestamp=uint_to_bytes(starting_timestamp), sender=locker_wallet.address)

    contract.execute_function('increaseLockTime(uint256)', args=[uint_to_bytes(2**256 - starting_timestamp - 5)], 
                              timestamp=uint_to_bytes(starting_timestamp+1),
                              sender=locker_wallet.address)
    import pdb; pdb.set_trace()
    contract.execute_function('withdraw()', [], timestamp=uint_to_bytes(starting_timestamp+2),
                              sender=locker_wallet.address)
    import pdb; pdb.set_trace()

    universe.assert_constraints(
      universe.contracts[locker_wallet.address].starting_wallet_amount == 0,
      universe.contracts[locker_wallet.address].wallet_amount == eth_to_wei(5)
    )


def test_timelock_exploit():
    binary = load_binary('contracts/build/TimeLock.bin')

    universe = Universe()
    contract = universe.deploy_contract(binary)

    locker_wallet = universe.deploy_wallet(starting_wallet_amount=eth_to_wei(5))

    starting_timestamp = int(datetime(2018, 1, 1).timestamp())

    contract.execute_function('deposit()', [], call_value=uint_to_bytes(eth_to_wei(5)), 
                              timestamp=uint_to_bytes(starting_timestamp), sender=locker_wallet.address)

    # contract.execute_function('increaseLockTime(uint256)', args=[uint_to_bytes(2**256 - starting_timestamp - 5)], 
    #                           timestamp=uint_to_bytes(starting_timestamp+1), call_value=uint_to_bytes(0),
    #                           sender=locker_wallet.address)

    import pdb; pdb.set_trace()
    universe.sender_address = locker_wallet.address
    week_in_seconds = 60 * 60 * 24 * 7
    acceptance_criteria = [
        universe.first_timestamp == starting_timestamp + 1,
        universe.first_timestamp + week_in_seconds > universe.last_timestamp,
        locker_wallet.wallet_amount == eth_to_wei(5),
        locker_wallet.starting_wallet_amount == 0
    ]
    executor = SpeculativeUniverseExecutor(universe, max_invocations=2)
    solutions = executor.get_solutions([contract.address], acceptance_criteria)

    import pdb; pdb.set_trace()
    pass
    # program = load_binary('contracts/build/TimeLock.bin-runtime')
    # machine = SpeculativeMachine(program=program, max_invocations=2, logging=False)

    # starting_timestamp = int(datetime(2018, 1, 1).timestamp())

    # machine.execute_deterministic_function(func_sig('deposit()'),
    #                                        call_value=eth_to_wei(5),
    #                                        timestamp=uint_to_bytes(starting_timestamp),
    #                                        sender=machine.sender_address)


    # acceptance_criteria = [
    #     machine.first_timestamp == starting_timestamp + 1,
    #     machine.first_timestamp + week_in_seconds > machine.last_timestamp,
    #     machine.attacker_wallet > machine.attacker_wallet_starting
    # ]

    # machine.pc = 0
    # possible_ends = SpeculativeMachineExecutor(machine).possible_ends(acceptance_criteria=acceptance_criteria)

    # summary = summarise_possible_end(possible_ends[0])

    # assert summary['inputs'][0]['data']['func_info']['name'] == 'increaseLockTime(uint256)'
    # assert summary['inputs'][0]['data']['args'][0]['val'] < 2 ** 256
    # assert summary['inputs'][0]['data']['args'][0]['val'] > 2 ** 255

    # assert summary['inputs'][1]['data']['func_info']['name'] == 'withdraw()'


# contract underflow_token {
#   mapping(address => uint) balances;
#   uint public totalSupply;
#   constructor(uint _initialSupply) public {
#     balances[msg.sender] = totalSupply = _initialSupply;
#   }
#   function transfer(address _to, uint _value) public returns (bool) {
#     require(balances[msg.sender] - _value >= 0);
#     balances[msg.sender] -= _value;
#     balances[_to] += _value;
#     return true;
#   }
#   function balanceOf(address _owner) public view returns (uint balance) {
#     return balances[_owner];
#   }
# }

def test_underflow_token_exploit_actually_works():
    program = load_binary('contracts/build/underflow_token.bin')

    constructor_address = pad_bytes_to_address(b'xConstructorx')
    machine = SpeculativeMachine(program=program, max_invocations=2, logging=False)
    machine.deploy(program, [uint_to_bytes(0)], sender=constructor_address)

    return_value = machine.execute_deterministic_function(func_sig('transfer(address,uint256)'),
                                                          args=[constructor_address, uint_to_bytes(123)],
                                                          sender=machine.sender_address)
    #import pdb; pdb.set_trace()

    return_value = machine.execute_deterministic_function(func_sig('balanceOf(address)'),
                                                          args=[constructor_address],
                                                          sender=machine.sender_address)
    assert bytes_to_uint(return_value.args[0]) == 123
